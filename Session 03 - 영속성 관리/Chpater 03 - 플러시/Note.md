# 플러시
> 작성자: 럭키/이현석

## 목차
- [플러시](#플러시)
  - [목차](#목차)
    - [1. 플러시란](#1-플러시란)
    - [2. 영속성 컨텍스트를 플러시하는 방법](#2-영속성-컨텍스트를-플러시하는-방법)
        - [JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유](#jpql-쿼리-실행시-플러시가-자동으로-호출되는-이유)
    - [3. 플러시 모드 옵션](#3-플러시-모드-옵션)
    - [4. 정리](#4-정리)

---
## 1. 플러시란?
</br>
쓰기 지연 SQL 저장소에 쌓아둔 sql 쿼리문을 데이터베이스에 전달하는 작업</br>
즉, 영속성 컨텍스트의 변경 사항과 데이터베이스를 맞추는 작업

</br>커밋이 되면 플러시가 자동으로 발생한다고 봐도 좋다.
</br>플러시가 발생하면 
- 변경 감지(dirty checking)
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소(등록, 수정, 삭제 쿼리가 존재)의 쿼리를 데이터베이스에 전송

의 작업이 일어난다.

</br>플러시 발생시 데이터베이스 트랜잭션이 커밋되는 것이 아닌 플러시를 통해 데이터를 보내고 커밋이 된다.

---
## 2. 영속성 컨텍스트를 플러시하는 방법
</br>

- **em.flush()** - 직접 호출
- **트랜잭션 커밋** - 플러시 자동 호출
- **JPQL 쿼리 실행** - 플러시 자동 호출

</br>+) 플러시를 하면 1차 캐시가 지워지는가 ?
</br> -> 플러시라는 단어가 주는 느낌이 데이터를 보내고 지우는 느낌이 드나, 플러시를 하면 쓰기 지연 SQL 저장소에 쌓여있던 sql 쿼리문들이 데이터베이스에 반영이 되는 과정일 뿐이다. 플러시가 삭제를 하는 그런 작업은 아니다.

### JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유

```
    ```
    em.persist(memberA);
    em.persist(memberB);
    em.persist(memberC);

    //중간에 JPQL 실행
    query = em.createQuery("select m from Member m", Member.class);
    List<Member> members= query.getResultList();
    ```
```
위 상황에서 memberA,B,C는 아직 데이터베이스에 저장이 되지 않은 상태
</br>여기서 아래의 쿼리를 날리면 문제가 생긴다.
</br>그래서 JPA는 이를 방지하고자 JPQL 실행시에 무조건 플러시를 호출한다. 그 후 아래의 쿼리를 실행한다.

---
## 3. 플러시 모드 옵션
</br>

    em.setFlushMode(FlushModeType.COMMIT)

- **FlushModeType.AUTO**: 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- **FlushModeType.COMMIT**: 커밋할 때만 플러시

가끔 이게 도움이 될 때가 있긴 하다. DB에 쿼리를 바로 날릴 필요가 없고, 다른 테이블을 조회하는 경우에 플러시를 한다고 이점을 얻을 수는 없어서 이점이 될수는 있다.

**그러나 이 옵션을 건드릴 일이 거의 없다. 큰 도움이 되지 않다.**
**가급적 손대지 않고 사용하는 게 좋다.**

---
## 4. 정리
<br>

플러시는!
- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨

참고로, JPA는 동시성에 대한 문제를 트랜잭션에 위임해서 사용한다.