# 페치 조인 2 - 한계
> 작성자: @joowojr

## 목차
### - 페치 조인의 특징과 한계 (1)
### - 페치 조인의 특징과 한계 (2)
### - 페치 조인 정리

## 1. 페치 조인의 특징과 한계
### ❗️ 페치 조인 대상에는 별칭을 줄 수 없다.(별칭 사용하지 않는게 관례)
  - 하이버네이트는 가능하나, 가급적 사용X
    ```java
    String query = "select t From Team t join fetch t.members m";​에서 m을 사용하면 안됨.
    ```
  - 팀을 조회하는데 맴버만 따로 조회해서 조작한다는 것 자체가 위험한 행위, JPA의 그래프 탐색의 의도는 연관된 모든 데이터를 가지고 오는 것이다.
  - 만일 Members에서 특정한 member만 필터로 조회해 가져오고 싶다면 Team과 Member의 Fetch 조인이 아닌, Member에서 조회하는 방식으로 해결해야 한다.
    ```java
    select t From Team t join fetch t.memberList m; // -> x
    select m From Member m join m.team where m.age > 10; // -> o
    ```
  - 특정 조건의 데이터만 조작하는 경우에도, 해당되지 않는 나머지 데이터들이 변경되거나 제거될 수 있어 데이터 정합성 문제가 발생한다. 
    ex ) CASCADE와 같은 설정이 걸린 경우
  - 또 같은 엔티티의 컬렉션을 한 쪽에서는 전체 조회하고, 한쪽에서는 필터를 통해 10개만 가져왔을때, 영속성 컨텍스트 입장에서는 같은 엔티티의 컬렉션의 데이터가 다르기에 애매한 입장이 된다.
  - 예외로 사용하게 되는 때는 A 와 B의 Fetch 조인 B와 C의 fetch 조인 이런식으로 사용할 때도 있다고 하지만, 정합성 이슈 때문에 거의 사용하지 않는다고 합니다.

### ❗️ 둘 이상의 컬렉션은 페치 조인 할 수 없다.
  - 일대다의 경우 데이터 뻥튀기가 발생되는데,  둘 이상의 컬렉션에 패치 조인을 사용하게 되면 데이터 정합성에 문제가 발생할 수 있다.
![image](https://github.com/luke0408/study_for_jpa_basic/assets/85955988/1aa47d3c-9310-40d3-b9b3-fb561aae1432)
    
### ❗️ 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
  - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    - 데이터 뻥튀기가 안 되기 때문 !
  - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)

## 2. 페치 조인의 특징과 한계
- fetch join은 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화.
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함.
- @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩.
- 최적화가 필요한 곳은 페치 조인 적용.
  - 즉, N + 1 문제가 발생하는 곳에만 페치 조인을 적용 한다.

## 3. 페치 조인 정리
- 모든 것을 페치 조인으로 해결할 수 는 없다.
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다.
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터만 조회해서 DTO로 반환 하는것이 효과적이다.
